\chapter{Empirical Analysis}

Both approaches support the following operations:

\begin{description}

  \item[$\textsc{insert}(i,d)$] Inserts an element with data $d$ at index $i$.

  \item[$\textsc{modify}(i,d)$] Modifies the data of the element at index $i$ to
  $d$.

  \item[$\textsc{remove}(i)$] Removes the element at index $i$.

  \item[$\textsc{access}(v,i)$] Returns the value of the element at index $i$ in
  version $v$.

%   \item[$\textsc{num\_versions}()$] Returns the total number of versions.
% 
%   \item[$\textsc{head\_at}(v)$] Returns the head node of the list at version
%   $v$.
% 
%   \item[$\textsc{size\_at}(v)$] Returns the size of the list at version $v$.

\end{description}

In testing the performance of the approaches in practice, we will look at how
they perform under various usage scenarios.

When either of the two approaches are to be used in practice, one can imagine
different usage scenarios:

\begin{description}

  \item[Uniformly random] The operations are executed in random order with no
  particular pattern. They may be weighted such that there is different
  probability for choosing different operations.

  \item[Sequential] The different types of operations are executed in sequences,
  e.g. first a number of \textsc{insert} operations, then a number of
  \textsc{access} operations. 

\end{description}

Different plausible usage scenarios have been implemented in order to test and
compare the performance of the Node Copying and Rollback approaches.

\begin{itemize}

  \item Pseudo-random choice uniformly distributed between the following four
  operations: insert, modify, remove, access.
  
  This scenario represents varied use of the data structure over time.

  \item Sequential bulk application of operations in the following order:
  insert, modify, remove, access.
  
  This scenario represents bulk usage of the data structure when access only
  happens after all the other operation types.

\end{itemize}

The above scenarios have been implemented in the program \texttt{msc}, which
accepts the following parameters:

\begin{description}

  \item[\texttt{-\@{}-count}/\texttt{-c \{num\}}] Total number of operations to carry
  out (default: 1000).

  \item[\texttt{-\@{}-randomize-operations}] If passed, applies the operations
  chosen at random between the four types. Otherwise, insertions are applied
  first, then modifications, then removals, then access operations (default:
  off).

  \item[\texttt{-\@{}-rollback-reorder-lazy}/\texttt{-l}] Will use the Rollback
  implementation for applying the operations (default).

  \item[\texttt{-\@{}-partiallypersistent}/\texttt{-p}] Will use the Node
  Copying implementation for applying the operations.

  \item[\texttt{-\@{}-max-snapshot-dist}/\texttt{-d \{num\}}] Maximum number of
  operations between snapshots (default: 65, applies only to the Rollback
  implementation).

  \item[\texttt{-\@{}-max-num-snapshots}/\texttt{-m \{num\}}] Maximum number of
  snapshots before adaptive fallback is carried out (default: 2000, applies only to the Rollback
  implementation).

  \item[\texttt{-\@{}-store-results}/\texttt{-s}] If set, will store results in
  an SQLite database file ``sqlite.db''.

\end{description}

\begin{figure}[!ht]
  \center
  \includegraphics[width=.8\textwidth]%
  {figures/graphs/access-duration-vs-count-avg.pdf}
  \includegraphics[width=.8\textwidth]%
  {figures/graphs/access-duration-per-op-vs-count-avg.pdf}

  \caption{Comparison of implementations and scenarious for various operation
  counts. Note how the Node Copying method keeps an approximately constant
  overhead factor per operation, whereas the Rollback method eventually hits the
  upper limit for full copies, and access time increases. It is reached faster
  in the sequential scenario since the full copies are larger.}

  \label{fig:access-duration-vs-count-avg}
\end{figure}

\section{Execution environment}
The empirical analysis is based on the output of executing different
implementations on a machine with the following specifications:

%\begin{table}[!ht]
\begin{tabular}{|l|l|}
\hline
CPU & Intel\textregistered Core\texttrademark i5-2400 CPU @ 3.10GHz $\times$ 4
\\
\hline
Memory & Hynix/Hyundai 2048 MB DDR3 RAM @ 1333 MHz $\times$ 2 \\
\hline
\end{tabular}
%\end{table}

\section{Plausible usage profiles}
