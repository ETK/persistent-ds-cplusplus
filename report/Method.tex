\chapter{Method}

\begin{enumerate}
  \item Description of Node Copying as a method
  \begin{enumerate}
    \item Node structure expansion
    \begin{enumerate}
      \item Back pointers
      \item Modifications
      \item Bounds on numbers of the above
      \item How it works
      \item Why it works
    \end{enumerate}
    \item Surrounding structure (collection of version information)
    \begin{enumerate}
      \item Considerations about effecient storage and retrieval of version info
    \end{enumerate}
  \end{enumerate}
  \item Description of ``Rollback'' as a method
  \begin{enumerate}
    \item Description of reordering and optimization of operations (see algorithm \ref{alg:opsort} on page \pageref{alg:opsort})
  \end{enumerate}
  \item Definitions of various application profiles (how the DS is used)
\end{enumerate}

\section{The Node Copying method}
Node Copying is a method described in \cite{Driscoll198986} by which a data
structure may be made partially persistent through the systematic expansion of
the nodes of the data structure. An auxillary data structure maintaining entry
points into the data structure, such as which node is the head of a linked list,
is also introduced. These two modifications of the data structure enable queries
to be made with $O(1)$ factor running time overhead and $O(1)$ space
consumption, given that the original data structure has an upper bounded
in-degree. In the following, I will describe in detail the general procedure as
well as giving the concrete example of the linked list.

\subsection{Node structure expansion}
As part of the Node Copying method, the node structure is expanded by adding two
arrays; one for ``back pointers'' and one for ``modifications''.

\begin{description}
  \item[Back pointers] 

  point back from a node $x$ to every node $y_i$ which points to $x$. When the
  in-degree has an upper bound, it is possible to restrict the size of the back
  pointers array. Whenever a node $y_i$ changes one of its pointers, the node
  $x$ it previously pointed to has the corresponding back pointer cleared, and
  the node $z$ it now points to has its corresponding back pointer set to point
  to $y_i$.

  \item[Modifications] store updates made to any of the fields of the node,
  including non-pointer fields, made since the node was created -- that is, the
  original field values from the time of construction remain unchanged. A
  modification record consist of a version number a field identifier and a
  value.

  When a field is to be modified on a node whose modifications array is already
  full, a copy of the node is constructed using the latest version of each field
  (including the one which is to be changed), thus resulting in a new node with
  an empty modifications array. The back pointers are also copied from the
  original node, and if the field being updated is a pointer field, the
  corresponding back pointer is updated in the destination node. This procedure
  is why the overall method is called Node Copying. A constant maximum number of
  modifications records is chosen such that node copying will have an amortized
  cost of $O(1)$.
\end{description}

\subsubsection{Amortized cost of Node Copying}
\todo[inline]{Write up proof of amortized time cost of node copying}

\section{Rollback}
Rollback is an approach to persistence based on the techniques described in
\cite{Tsotras1995237}, namely the combination of the na\"ive ``log'' and
``copy'' methods.
\todo[inline]{Describe ``log'' and ``copy'' as well as their hybrid, and justify
its comparison to Node Copying.}

\subsection{Operations batch optimization}
See pseudo-code for the reordering in algorithm \ref{alg:opsort}.
\todo[inline]{Describe properly the purpose and how it works, including proof}

\begin{algorithm}[!h]
  \caption{Algorithm for sorting a set of operations}
  \label{alg:opsort}
  \begin{algorithmic}
    \Function {SortOperations}{set of operations $O$}
      \State result $\gets$ empty set
      \While {$O$ not empty}
        \State // Find left-most operation with minimum index of application
        \State $o_{min} \gets$ op. with minimum index of application
        \State $index_{min} \gets$ index in $O$ of $o_{min}$
        \State \textsc{remove} $o_{min}$ from $O$
        \Statex
        \State // Compensate operations which will now be after $o_{min}$ instead of before
        \If {$o_{min}$ is an \textsc{insert} op.}
          \For {each op. $o_i,o_i\in \left\{O | 0\le i<index_{min}\right\}$ }
            \State \textsc{index}($o_i$) $\gets$ \textsc{index}($o_i$)-1
          \EndFor
        \ElsIf {$o_{min}$ is a \textsc{remove} op.}
          \For {each op. $o_i,o_i\in \left\{O | 0\le i<index_{min}\right\}$}
            \State \textsc{index}($o_i$) $\gets$ \textsc{index}($o_i$)+1
          \EndFor
        \EndIf
        \State \textsc{append} $o_{min}$ to result
      \EndWhile
      \Statex
      \State \Return result
    \EndFunction
  \end{algorithmic}
\end{algorithm}
